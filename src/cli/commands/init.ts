// SPDX-License-Identifier: Apache-2.0 OR LicenseRef-LEHRO-Solutions-Commercial
// Copyright (c) 2025 LEHRO Solutions
import * as fs from 'fs';
import * as path from 'path';
import { createSpinner } from '../utils/spinner';
import { telemetry } from '../../core/telemetry';
import { ui } from '../utils/ui';
import { mergeWithConfig } from '../utils/config';

interface InitOptions {
  template?: string;
  output?: string;
}

const VALID_TEMPLATES = ['openapi', 'graphql'];

export async function initCommand(options: InitOptions) {
  // Merge with config file defaults
  const mergedOptions = mergeWithConfig(options, 'init');
  const { template = 'openapi', output = '.' } = mergedOptions;
  const targetDir = path.resolve(output);

  // Validate template
  if (!VALID_TEMPLATES.includes(template.toLowerCase())) {
    ui.error('Invalid template', `Template must be one of: ${VALID_TEMPLATES.join(', ')}`);
    ui.info('Tip', 'Use -t openapi for OpenAPI or -t graphql for GraphQL projects');
    process.exit(1);
  }

  ui.showCompactBanner();
  ui.sectionHeader('Initializing New Project');

  telemetry.track('init_start', { template });

  if (fs.existsSync(targetDir) && fs.readdirSync(targetDir).length > 0) {
    ui.error('Directory is not empty', `Path: ${ui.filePath(targetDir)}`);
    ui.info('Tip', 'Choose an empty directory or create a new one');
    telemetry.track('init_fail', { reason: 'directory_not_empty' });
    process.exit(1);
  }

  const spinner = await createSpinner(`Creating ${template} project structure`);
  if (spinner.start) spinner.start();

  try {
    // Create directory structure
    ui.step(1, 4, 'Creating directories...');
    fs.mkdirSync(targetDir, { recursive: true });
    fs.mkdirSync(path.join(targetDir, 'specs'));
    fs.mkdirSync(path.join(targetDir, 'generated'));
    fs.mkdirSync(path.join(targetDir, 'tests'));

    // Create base files
    ui.step(2, 4, 'Generating package.json...');
    const packageJson = {
      name: path.basename(targetDir),
      version: '1.0.0',
      description: `Generated ${template.toUpperCase()} API project`,
      scripts: {
        generate: 'gidevo-api-tool generate -s specs/api.yaml -o generated',
        validate: 'gidevo-api-tool validate specs/api.yaml',
        'validate:strict': 'gidevo-api-tool validate specs/api.yaml --strict'
      }
    };

    fs.writeFileSync(
      path.join(targetDir, 'package.json'),
      JSON.stringify(packageJson, null, 2)
    );

    // Create sample spec based on template
    ui.step(3, 4, `Creating ${template} spec template...`);
    if (template === 'openapi') {
      const spec = {
        openapi: '3.0.0',
        info: { 
          title: 'My API', 
          version: '1.0.0',
          description: 'Generated by GIDEVO API Tool'
        },
        servers: [
          { url: 'http://localhost:3000', description: 'Development server' }
        ],
        paths: {
          '/health': {
            get: {
              summary: 'Health check',
              operationId: 'getHealth',
              tags: ['System'],
              responses: { 
                '200': { 
                  description: 'OK',
                  content: {
                    'application/json': {
                      schema: {
                        type: 'object',
                        properties: {
                          status: { type: 'string', example: 'healthy' },
                          timestamp: { type: 'string', format: 'date-time' }
                        }
                      }
                    }
                  }
                } 
              }
            }
          }
        }
      };
      fs.writeFileSync(
        path.join(targetDir, 'specs', 'api.yaml'),
        JSON.stringify(spec, null, 2)
      );
    } else if (template === 'graphql') {
      const schema = `# Generated by GIDEVO API Tool
# GraphQL Schema Definition

type Query {
  """
  Returns a greeting message
  """
  hello(name: String): String!
  
  """
  Health check endpoint
  """
  health: HealthStatus!
}

type HealthStatus {
  status: String!
  timestamp: String!
}

schema {
  query: Query
}
`.trim();
      fs.writeFileSync(path.join(targetDir, 'specs', 'schema.graphql'), schema);
    }

    // Create README
    ui.step(4, 4, 'Creating documentation...');
    const readme = `# ${path.basename(targetDir)}

Generated ${template.toUpperCase()} API project using [GIDEVO API Tool](https://github.com/lehrosolutions/gidevo-api-tool).

## Quick Start

\`\`\`bash
# Generate SDK
npm run generate

# Validate spec
npm run validate
\`\`\`

## Project Structure

\`\`\`
${path.basename(targetDir)}/
├── specs/          # API specifications
├── generated/      # Generated SDK code
├── tests/          # Test files
└── package.json    # Project configuration
\`\`\`

## Commands

- \`npm run generate\` - Generate SDK from API spec
- \`npm run validate\` - Validate API specification
- \`npm run validate:strict\` - Strict OpenAPI validation
`;
    fs.writeFileSync(path.join(targetDir, 'README.md'), readme);

    // Stop spinner and display success
    spinner.stop();
    
    ui.success('Project initialized successfully!');
    
    ui.divider();
    
    ui.table(
      ['File', 'Description'],
      [
        [ui.filePath('specs/'), 'API specifications'],
        [ui.filePath('generated/'), 'Generated SDK output'],
        [ui.filePath('tests/'), 'Test files'],
        [ui.filePath('package.json'), 'Project configuration'],
        [ui.filePath('README.md'), 'Documentation'],
      ]
    );

    ui.nextSteps([
      `cd ${path.basename(targetDir)}`,
      'Edit your API spec in specs/',
      'Run: gidevo-api-tool generate -s specs/api.yaml',
    ]);

    telemetry.track('init_success', { template });
  } catch (error: any) {
    spinner.stop();
    ui.error('Initialization failed', error.message);
    telemetry.captureException(error);
    process.exit(1);
  }
}
