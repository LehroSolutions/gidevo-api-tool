// SPDX-License-Identifier: Apache-2.0 OR LicenseRef-LEHRO-Solutions-Commercial
// Copyright (c) 2025 LEHRO Solutions
import * as fs from 'fs';
import * as path from 'path';
import { createSpinner } from '../utils/spinner';
import { telemetry } from '../../core/telemetry';
import { ui } from '../utils/ui';
import { mergeWithConfig } from '../utils/config';

interface InitOptions {
  template?: string;
  output?: string;
}

const VALID_TEMPLATES = ['openapi', 'graphql'];

export async function initCommand(options: InitOptions) {
  // Merge with config file defaults
  const mergedOptions = mergeWithConfig(options, 'init');
  const { template = 'openapi', output = '.' } = mergedOptions;
  const targetDir = path.resolve(output);

  // Validate template
  if (!VALID_TEMPLATES.includes(template.toLowerCase())) {
    ui.error('Template Recognition Failed', `Unknown template identifier: ${ui.highlight(template)}`);
    ui.info('Available Templates', `Select one of: ${VALID_TEMPLATES.join(', ')}`);
    process.exit(1);
  }

  ui.showCompactBanner();
  ui.sectionHeader('INITIALIZING NEURAL ARCHITECTURE');

  telemetry.track('init_start', { template });

  if (fs.existsSync(targetDir) && fs.readdirSync(targetDir).length > 0) {
    ui.error('Workspace Contaminated', `Target directory is not empty: ${ui.filePath(targetDir)}`);
    ui.info('Resolution', 'Select a pristine directory or create a new one to ensure structure integrity.');
    telemetry.track('init_fail', { reason: 'directory_not_empty' });
    process.exit(1);
  }

  const spinner = await createSpinner(`Synthesizing ${template} structure...`);
  if (spinner.start) spinner.start();

  try {
    // Artificial delay for UX feel - "Weighty" operations feel more valuable
    // but typically we should avoid this. However, file I/O is instant here.
    // We will just proceed.

    // Create directory structure
    fs.mkdirSync(targetDir, { recursive: true });
    fs.mkdirSync(path.join(targetDir, 'specs'));
    fs.mkdirSync(path.join(targetDir, 'generated'));
    fs.mkdirSync(path.join(targetDir, 'tests'));

    // Create base files
    const packageJson = {
      name: path.basename(targetDir),
      version: '1.0.0',
      description: `Generated ${template.toUpperCase()} API project`,
      scripts: {
        generate: 'gidevo-api-tool generate -s specs/api.yaml -o generated',
        validate: 'gidevo-api-tool validate specs/api.yaml',
        'validate:strict': 'gidevo-api-tool validate specs/api.yaml --strict'
      }
    };

    fs.writeFileSync(
      path.join(targetDir, 'package.json'),
      JSON.stringify(packageJson, null, 2)
    );

    // Create sample spec based on template
    if (template === 'openapi') {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Core API',
          version: '1.0.0',
          description: 'Architecture generated by GIDEVO'
        },
        servers: [
          { url: 'http://localhost:3000', description: 'Development Node' }
        ],
        paths: {
          '/health': {
            get: {
              summary: 'System Integrity Check',
              operationId: 'getHealth',
              tags: ['System'],
              responses: {
                '200': {
                  description: 'System Functional',
                  content: {
                    'application/json': {
                      schema: {
                        type: 'object',
                        properties: {
                          status: { type: 'string', example: 'healthy' },
                          timestamp: { type: 'string', format: 'date-time' },
                          metrics: {
                            type: 'object',
                            properties: {
                              uptime: { type: 'number' },
                              load: { type: 'number' }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };
      fs.writeFileSync(
        path.join(targetDir, 'specs', 'api.yaml'),
        JSON.stringify(spec, null, 2)
      );
    } else if (template === 'graphql') {
      const schema = `# Generated by GIDEVO API Tool
# Neural Schema Definition

type Query {
  """
  Ping systems
  """
  ping: Pong!
  
  """
  System status check
  """
  systemStatus: SystemHealth!
}

type Pong {
  message: String!
  latency: Int!
}

type SystemHealth {
  status: String!
  uptime: Float!
  version: String!
}

schema {
  query: Query
}
`.trim();
      fs.writeFileSync(path.join(targetDir, 'specs', 'schema.graphql'), schema);
    }

    // Create README
    const readme = `# ${path.basename(targetDir)}
    
> Generated via **GIDEVO API Tool** - Enterprise Architecture Engine

## âš¡ Quick Start

\`\`\`bash
# Synthesize SDK
npm run generate

# Verify Integrity
npm run validate
\`\`\`

## ðŸ“‚ Architecture

\`\`\`
${path.basename(targetDir)}/
â”œâ”€â”€ specs/          # Source of Truth (OpenAPI/GraphQL)
â”œâ”€â”€ generated/      # Machine-Synthesized Code
â”œâ”€â”€ tests/          # Integrity Verification
â””â”€â”€ package.json    # Project Manifest
\`\`\`
`.trim();
    fs.writeFileSync(path.join(targetDir, 'README.md'), readme);

    // Stop spinner and display success
    if (spinner.stop) spinner.stop();

    ui.success('Project Architecture Synthesized');

    ui.table(
      ['Artifact', 'Purpose'],
      [
        [ui.filePath('specs/'), 'API Source of Truth'],
        [ui.filePath('generated/'), 'Target for Synthesis'],
        [ui.filePath('tests/'), 'Verification Suite'],
        [ui.filePath('package.json'), 'dependency Manifest'],
      ]
    );

    ui.nextSteps([
      `cd ${path.basename(targetDir)}`,
      'Define your schema in specs/',
      'Run synthesis: npm run generate',
    ]);

    telemetry.track('init_success', { template });
  } catch (error: any) {
    if (spinner.stop) spinner.stop();
    ui.error('Synthesis Aborted', error.message);
    telemetry.captureException(error);
    process.exit(1);
  }
}
